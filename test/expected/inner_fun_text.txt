function symlink_contents_to_dir() {
if [[ -z "$1" ]]; then
echo "arg 1 to symlink_contents_to_dir is unexpectedly empty"
exit 1
fi
if [[ -z "$2" ]]; then
echo "arg 2 to symlink_contents_to_dir is unexpectedly empty"
exit 1
fi
local target="$2"
mkdir -p "$target"
if [[ -f "$1" ]]; then
symlink_to_dir "$1" "$target"
elif [[ -L "$1" ]]; then
local actual=$(readlink "$1")
symlink_contents_to_dir "$actual" "$target"
else
symlink_to_dir "$(readlink -f $1)" "$target"
fi
}
function symlink_to_dir() {
if [[ -z "$1" ]]; then
echo "arg 1 to symlink_to_dir is unexpectedly empty"
exit 1
fi
if [[ -z "$2" ]]; then
echo "arg 2 to symlink_to_dir is unexpectedly empty"
exit 1
fi
local target="$2"
# we symlink the ext_build_deps as well but we delete it after :)
# this is a huge performance improvement than the original recursive version
# so these extra copies are an okay performance loss
cp -prsL "$1" --no-target-dir "$target"
SAVEIFS=$IFS
IFS=$'
'
find -L "$target" -type d -name "*.ext_build_deps" -prune -exec rm -r \{\} \;

# In order to be able to use `replace_in_files`, we ensure that we create copies of specfieid
# files so updating them is possible.
local files_to_copy=($(find -L "$target" -type f \( -name "*.pc" -or -name "*.la" -or -name "*-config" -or -name "*.mk" -or -name "*.cmake" \) -printf "%P\n"))
IFS=$SAVEIFS
for f in "${files_to_copy[@]}"; do
dest="$target/$f"
src="$1/$f"
cp -p "$src" "$dest" && chmod +w "$dest" && touch -r "$src" "$dest"
done

}
symlink_contents_to_dir $SOURCE_DIR $TARGET_DIR